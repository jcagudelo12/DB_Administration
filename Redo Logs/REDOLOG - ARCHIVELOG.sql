-- **************************************************************** --
-- **                          REDO LOGS                         ** --
-- **************************************************************** --

SELECT * FROM V$LOG; -- con esto consulto en RAM

-- REDO LOG FILES

SELECT * FROM V$LOGFILE; -- con esto consulto en HDD

-- FORZAR UN LOG SWITCH

ALTER SYSTEM SWITCH LOGFILE;
SELECT * FROM V$LOG;

-- MULTIPLEXAR (HACER COPIA) DE LOS REDO LOG FILES.
SELECT * FROM V$LOG;   -- 3 GRUPOS, CADA GRUPO TIENE UN SOLO MIEMBRO
                       -- SE MULTIPLEXA AGREGANDO MIEMBROS A LOS GRUPOS

-- AGREGAR MIEMBRO
ALTER DATABASE ADD LOGFILE MEMBER 'C:\ORACLE\ORADATA\ORCL\REDO01-COPIA.LOG' TO GROUP 1;
ALTER DATABASE ADD LOGFILE MEMBER 'C:\ORACLE\ORADATA\ORCL\REDO02-COPIA.LOG' TO GROUP 2;
ALTER DATABASE ADD LOGFILE MEMBER 'C:\ORACLE\ORADATA\ORCL\REDO03-COPIA.LOG' TO GROUP 3;

SELECT * FROM V$LOG;  -- YA CADA GRUPO TIENE DOS MIEMBROS
SELECT * FROM V$LOGFILE;  -- ESTADO DE LOS TRES NUEVOS REDOLOGS - INVALID
                          -- NO ES PROBLEMA
                          
-- EL REDOLOG FILE CURRENT ES EL 3. HAGAMOS UN LOG SWITCH
ALTER SYSTEM SWITCH LOGFILE;
SELECT * FROM V$LOG;  
SELECT * FROM V$LOGFILE;  -- YA, LA COPIA DEL REDOLOG 1 NO APARECE INVALID.

-- CREAR NUEVO GRUPO, PARA QUE EL CICLO SEA MAS LARGO
ALTER DATABASE ADD LOGFILE GROUP 5
('C:\ORACLE\ORADATA\ORCL\REDO05.LOG',
 'C:\ORACLE\ORADATA\ORCL\REDO05-COPIA.LOG') SIZE 100M;

SELECT * FROM V$LOG;    -- NUEVO GRUPO EN ESTADO UNUSED
ALTER SYSTEM SWITCH LOGFILE;   -- YA EL GRUPO 5 ESTA CURRENT
SELECT * FROM V$LOGFILE;

-- ELIMINAR MIEMBROS DE UN GRUPO
-- CUAL ES EL REDOLOG CURRENT?
SELECT * FROM V$LOG; 

-- TRATEMOS DE BORRAR UN MIEMBRO DEL GRUPO CURRENT
ALTER DATABASE DROP LOGFILE MEMBER 'C:\ORACLE\ORADATA\ORCL\REDO05-COPIA.LOG'; -- NO DEJA

ALTER SYSTEM SWITCH LOGFILE;

ALTER DATABASE DROP LOGFILE MEMBER 'C:\ORACLE\ORADATA\ORCL\REDO03-COPIA.LOG'; -- SI DEJA

SELECT * FROM V$LOG; 
SELECT * FROM V$LOGFILE;  -- 7 REDOLOG FILES

-- SE PUEDE BORRAR EL UNICO MIEMBRO DE UN GRUPO?
ALTER DATABASE DROP LOGFILE MEMBER 'C:\ORACLE\ORADATA\ORCL\REDO05.LOG';  -- NO DEJA

-- BORRAR UN GRUPO
ALTER DATABASE DROP LOGFILE GROUP 3;  -- NO SE BORRAN SUS REDO LOG FILES (FISICOS)

-- **************************************************************** --
-- **                          ARCHIVELOG                        ** --
-- **************************************************************** --

-- DOS MODOS
-- ARCHIVELOG: ASI DEBERÍA ESTAR UNA BASE DE DATOS EN PRODUCCIÓN
-- NOARCHIVELOG: ES UN SUICIDIO

-- MODO DE LA BASE DE DATOS
SELECT * FROM V$DATABASE;  -- NOARCHIVELOG

-- PARA MODIFICAR EL ESTADO A ARCHIVELOG
ALTER SYSTEM SET LOG_ARCHIVE_DEST_1 = 'LOCATION=C:/ARCHIVELOGS';
ALTER SYSTEM SET LOG_ARCHIVE_DEST_2 = 'LOCATION=USE_DB_RECOVERY_FILE_DEST';
SHOW PARAMETER DB_RECOVERY_FILE_DEST

ALTER SYSTEM SET LOG_ARCHIVE_FORMAT='arch_%t_%s_%r.arc' SCOPE = SPFILE;

-- POR SQLPLUS:
-- SHUTDOWN IMMEDIATE
-- STARTUP MOUNT
-- ARCHIVE LOG LIST
-- ALTER DATABASE ARCHIVELOG
-- ARCHIVE LOG LIST
-- ALTER DATABASE OPEN

SELECT * FROM V$DATABASE;

-- AHORA, CADA VEZ QUE SE LLENE UN REDOLOG SE DEBE GENERAR UN ARCHIVELOG
-- SIMULEMOS:

ALTER SYSTEM SWITCH LOGFILE;  -- YA HAY ARCHIVELOGS

ALTER SYSTEM SWITCH LOGFILE;  -- EL NUEVO ARCHIVELOG ES MAS PEQUEÑO